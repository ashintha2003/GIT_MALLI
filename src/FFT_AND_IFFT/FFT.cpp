#include "FFT.h"

// THIS FUNCTION DOES THE FFT (AFTER THIS FUNCTION IS CALLED NUMBER_OF_SAMPLE IS HALFED)
void FFT(){ 

    /*if(FFT_ITERATION == 1){
       FFT_ITERATION = FFT_ITERATION + 1;
       FFT_SAMPLES = SAMPLE_1;
    }else if(FFT_ITERATION == 2){
        FFT_ITERATION = FFT_ITERATION + 1;
        FFT_SAMPLES = SAMPLE_2;
    }else if(FFT_ITERATION == 3){
        FFT_ITERATION = 1;
        FFT_SAMPLES = SAMPLE_3;
    }*/
    
    for(int i=1; i<=MAX_ITERATION; i++){
      
        if(i == FFT_ITERATION){
            if(i == MAX_ITERATION){
                FFT_ITERATION = 5;
            }else{
                FFT_ITERATION = FFT_ITERATION + 1;
            }
            FFT_SAMPLES = SAMPLE_ARRAY[i - 1];
            break;  //STOP THE FOR LOOP AND GET OUT 
        }
        
    }
    

    // INITIALIZE THE VARIABLES
    uint16_t LEFT_POINTER = 0;
    uint16_t RIGHT_POINTER = 0;
    uint16_t KEY = 1;
    uint16_t NUMBER_OF_SETS = 0; // NUMBER_OF_SETS = NUMBER_OF_SAMPLES/KEY
    //

    
    while (KEY <= NUMBER_OF_SAMPLES){
        KEY = KEY * 2; // MULTIPLY THE VALUE BY 2 EACH TIME THE TREE MOVE INTO THE TOP
        NUMBER_OF_SETS = NUMBER_OF_SAMPLES / KEY;
        for (uint16_t i = 0; i < NUMBER_OF_SETS; i++){
            for (uint16_t j = 0; j < KEY / 2; j++){
               LEFT_POINTER = (KEY * i) + j;
               RIGHT_POINTER = (KEY/2) + (KEY * i) + j;
               CALCULATOR(LEFT_POINTER, RIGHT_POINTER, j, KEY);  //CALL THE FUNCTION AND IT WILL UPDATE THE CELLS 
            }
        }
    }

    // PLOT THE SINGLE SIDE SPECTRUM FROM THE DOUBLE SIDE 
    float SAMPLE_FREQUENCY_PER_LENGTH = SAMPLING_FREQUENCY / (float)NUMBER_OF_SAMPLES;
    NUMBER_OF_SAMPLES = (NUMBER_OF_SAMPLES / 2) + 1;
    //MAGNITUDE_SAMPLES = (struct MAGNITUDE_SAMPLES *)calloc(NUMBER_OF_SAMPLES, sizeof(struct MAGNITUDE_SAMPLES));
    //

    //TAKE THE SINGLE SIDE MAGNITUDE SPECTRUM 
    for(uint16_t i=0; i<NUMBER_OF_SAMPLES; i++){
        if(i == 0){
            MAGNITUDE_SAMPLES[i].MAGNITUDE = hypotf(FFT_SAMPLES[i].REAL_VALUE, FFT_SAMPLES[i].IMAGINARY_VALUE);
            MAGNITUDE_SAMPLES[i].FREQUENCY = i * SAMPLE_FREQUENCY_PER_LENGTH;
            MAGNITUDE_SAMPLES[i].POSITION = i;
        }else{
            MAGNITUDE_SAMPLES[i].MAGNITUDE = 2*hypotf(FFT_SAMPLES[i].REAL_VALUE, FFT_SAMPLES[i].IMAGINARY_VALUE);
            MAGNITUDE_SAMPLES[i].FREQUENCY = i * SAMPLE_FREQUENCY_PER_LENGTH;
            MAGNITUDE_SAMPLES[i].POSITION = i;
        }
    }
    //

    MATLAB_FUNCTION("FREQUENCY", 2); // SEND THE VALUES INTO MATLAB AND PLOT THE GRAPH

    MAGNITUDE_SPECTRUM();
}



//THIS FUNCTION WILL DO THE COMPLEX CALCULATION AND UPDATE THE VALUES IN THE ARRAY ------------------------------
void CALCULATOR(uint16_t LEFT_POINTER, uint16_t RIGHT_POINTER, uint16_t K, uint16_t N){  

    // CALCULATE THE TWIDDLE FACTOR
    TWIDDLE_FACTOR.REAL_VALUE = (float)cos((-2.0 * PI * (double)K) / (double)N);      // x1
    TWIDDLE_FACTOR.IMAGINARY_VALUE = (float)sin((-2.0 * PI * (double)K) / (double)N); // y1
    //

    // CALCULATE THE TWIDDLE FACTOR PRODUCT
    TWIDDLE_PRODUCT.REAL_VALUE = (TWIDDLE_FACTOR.REAL_VALUE * FFT_SAMPLES[RIGHT_POINTER].REAL_VALUE) - (TWIDDLE_FACTOR.IMAGINARY_VALUE * FFT_SAMPLES[RIGHT_POINTER].IMAGINARY_VALUE);
    TWIDDLE_PRODUCT.IMAGINARY_VALUE = (TWIDDLE_FACTOR.REAL_VALUE * FFT_SAMPLES[RIGHT_POINTER].IMAGINARY_VALUE) + (FFT_SAMPLES[RIGHT_POINTER].REAL_VALUE * TWIDDLE_FACTOR.IMAGINARY_VALUE);
    INVERSE_TWIDDLE_PRODUCT.REAL_VALUE = -1 * TWIDDLE_PRODUCT.REAL_VALUE;
    INVERSE_TWIDDLE_PRODUCT.IMAGINARY_VALUE = -1 * TWIDDLE_PRODUCT.IMAGINARY_VALUE;
    //

    DUMMY.REAL_VALUE = FFT_SAMPLES[LEFT_POINTER].REAL_VALUE;
    DUMMY.IMAGINARY_VALUE = FFT_SAMPLES[LEFT_POINTER].IMAGINARY_VALUE;

    FFT_SAMPLES[LEFT_POINTER].REAL_VALUE = (DUMMY.REAL_VALUE + TWIDDLE_PRODUCT.REAL_VALUE);// / (float)NUMBER_OF_SAMPLES;
    FFT_SAMPLES[LEFT_POINTER].IMAGINARY_VALUE = (DUMMY.IMAGINARY_VALUE + TWIDDLE_PRODUCT.IMAGINARY_VALUE);// / (float)NUMBER_OF_SAMPLES;

    FFT_SAMPLES[RIGHT_POINTER].REAL_VALUE = (DUMMY.REAL_VALUE + INVERSE_TWIDDLE_PRODUCT.REAL_VALUE);// / (float)NUMBER_OF_SAMPLES;
    FFT_SAMPLES[RIGHT_POINTER].IMAGINARY_VALUE = (DUMMY.IMAGINARY_VALUE + INVERSE_TWIDDLE_PRODUCT.IMAGINARY_VALUE);// / (float)NUMBER_OF_SAMPLES;
}


// -------------------------------
void INVERSE_FFT(){

    NUMBER_OF_SAMPLES = (NUMBER_OF_SAMPLES - 1) * 2;  //TAKE THE ORGINAL NUMBER ROF SAMPLES

    //TAKE THE CONJUGATE WHILE CHANGING THE ORDER 
    uint16_t COUNTER_1 = 0;
    uint16_t INVERTED_VALUE = 0;
    struct SAMPLES DUMMY_SAMPLE;
    for(uint16_t i=0; i<NUMBER_OF_SAMPLES; i++){
        if(i==0){
          FFT_SAMPLES[i].IMAGINARY_VALUE = -1 * FFT_SAMPLES[i].IMAGINARY_VALUE;
        }else{
             INVERTED_VALUE = 0;
            uint16_t DUMMY_3 = i;
            for (int j = 0; j < POWER; j++){
                INVERTED_VALUE <<= 1;
                INVERTED_VALUE |= (DUMMY_3 & 1);
                DUMMY_3 >>= 1;
            }
           // FFT_SAMPLES[INVERTED_VALUE].REAL_VALUE = SAMPLES;
           if(INVERTED_VALUE >= i){
            DUMMY_SAMPLE.REAL_VALUE = FFT_SAMPLES[i].REAL_VALUE;
            DUMMY_SAMPLE.IMAGINARY_VALUE = -1 * FFT_SAMPLES[i].IMAGINARY_VALUE;

            FFT_SAMPLES[i].REAL_VALUE = FFT_SAMPLES[INVERTED_VALUE].REAL_VALUE;
            FFT_SAMPLES[i].IMAGINARY_VALUE = -1 * FFT_SAMPLES[INVERTED_VALUE].IMAGINARY_VALUE;

            FFT_SAMPLES[INVERTED_VALUE].REAL_VALUE = DUMMY_SAMPLE.REAL_VALUE;
            FFT_SAMPLES[INVERTED_VALUE].IMAGINARY_VALUE = DUMMY_SAMPLE.IMAGINARY_VALUE;
           }

            
        }
      //COUNTER_1 = COUNTER_1 + 1;
    }
    //

    //  FFT

 // INITIALIZE THE VARIABLES
    uint16_t LEFT_POINTER = 0;
    uint16_t RIGHT_POINTER = 0;
    uint16_t KEY = 1;
    uint16_t NUMBER_OF_SETS = 0; // NUMBER_OF_SETS = NUMBER_OF_SAMPLES/KEY
    //

    
    while (KEY <= NUMBER_OF_SAMPLES){
        KEY = KEY * 2; // MULTIPLY THE VALUE BY 2 EACH TIME THE TREE MOVE INTO THE TOP
        NUMBER_OF_SETS = NUMBER_OF_SAMPLES / KEY;
        for (uint16_t i = 0; i < NUMBER_OF_SETS; i++){
            for (uint16_t j = 0; j < KEY / 2; j++){
               LEFT_POINTER = (KEY * i) + j;
               RIGHT_POINTER = (KEY/2) + (KEY * i) + j;
               CALCULATOR(LEFT_POINTER, RIGHT_POINTER, j, KEY);  //CALL THE FUNCTION AND IT WILL UPDATE THE CELLS 
            }
        }
    }
    for(uint16_t i=0; i<NUMBER_OF_SAMPLES; i++){
        FFT_SAMPLES[i].REAL_VALUE = FFT_SAMPLES[i].REAL_VALUE / NUMBER_OF_SAMPLES;
        FFT_SAMPLES[i].IMAGINARY_VALUE = FFT_SAMPLES[i].IMAGINARY_VALUE / NUMBER_OF_SAMPLES;
    }
    //

    MATLAB_FUNCTION("TIME", 1);  //SEND THE VALUES TO MATLAB TO PLOT THE RECONSTRUCTED TIME DOMAIN SIGNAL 
    

    #ifdef DEBUG
    Serial.printf("\n\n-------------------------------------------------------------------------------");
    Serial.printf("\nTIME DOMAIN SIGNAL\n\n\n");
    for(uint16_t i=0; i<NUMBER_OF_SAMPLES; i++){
        Serial.printf("\nTIME{%.4f} = %.3f%+.3fj", (float)i * SAMPLING_TIME ,FFT_SAMPLES[i].REAL_VALUE, FFT_SAMPLES[i].IMAGINARY_VALUE);
    }
    #endif


    
}